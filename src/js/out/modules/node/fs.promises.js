<<<<<<< HEAD
function J(B,C={}){const G=[];if(B instanceof URL)throw new TypeError("Watch URLs are not supported yet");else if(Buffer.isBuffer(B))B=B.toString();else if(typeof B!=="string")throw new TypeError("Expected path to be a string or Buffer");let D=null;if(typeof C==="string")C={encoding:C};return S.watch(B,C||{},(z,A)=>{if(G.push({eventType:z,filename:A}),D){const H=D;D=null,H()}}),{async*[Symbol.asyncIterator](){let z=!1;while(!z){while(G.length){let A=G.shift();if(A.eventType==="close"){z=!0;break}if(A.eventType==="error")throw z=!0,A.filename;yield A}await new Promise((A)=>D=A)}}}}var S=Bun.fs(),I="::bunternal::",q={[I]:(B)=>{var C={[I]:function(G,D,z){var A;try{A=B.apply(S,z),z=void 0}catch(H){z=void 0,D(H);return}G(A)}}[I];return async function(...G){return await new Promise((D,z)=>{process.nextTick(C,D,z,G)})}}}[I],K=q(S.accessSync),L=q(S.appendFileSync),M=q(S.closeSync),N=q(S.copyFileSync),O=q(S.existsSync),P=q(S.chownSync),Q=q(S.chmodSync),U=q(S.fchmodSync),V=q(S.fchownSync),X=q(S.fstatSync),Y=q(S.fsyncSync),Z=q(S.ftruncateSync),_=q(S.futimesSync),$=q(S.lchmodSync),T=q(S.lchownSync),W=q(S.linkSync),k=q(S.lstatSync),E=q(S.mkdirSync),x=q(S.mkdtempSync),F=q(S.openSync),R=q(S.readSync),g=q(S.writeSync),h=q(S.readdirSync),j=q(S.readFileSync),w=q(S.writeFileSync),b=q(S.readlinkSync),u=q(S.realpathSync),d=q(S.renameSync),c=q(S.statSync),v=q(S.symlinkSync),a=q(S.truncateSync),y=q(S.unlinkSync),l=q(S.utimesSync),p=q(S.lutimesSync),m=q(S.rmSync),n=q(S.rmdirSync),t=(B,C,G)=>{return new Promise((D,z)=>{try{var A=S.writevSync(B,C,G)}catch(H){z(H);return}D({bytesWritten:A,buffers:C})})},o=(B,C,G)=>{return new Promise((D,z)=>{try{var A=S.readvSync(B,C,G)}catch(H){z(H);return}D({bytesRead:A,buffers:C})})},r={access:K,appendFile:L,close:M,copyFile:N,exists:O,chown:P,chmod:Q,fchmod:U,fchown:V,fstat:X,fsync:Y,ftruncate:Z,futimes:_,lchmod:$,lchown:T,link:W,lstat:k,mkdir:E,mkdtemp:x,open:F,read:R,write:g,readdir:h,readFile:j,writeFile:w,readlink:b,realpath:u,rename:d,stat:c,symlink:v,truncate:a,unlink:y,utimes:l,lutimes:p,rm:m,rmdir:n,watch:J,writev:t,readv:o,constants,[Symbol.for("CommonJS")]:0};export{t as writev,w as writeFile,g as write,J as watch,l as utimes,y as unlink,a as truncate,v as symlink,c as stat,n as rmdir,m as rm,d as rename,u as realpath,o as readv,b as readlink,h as readdir,j as readFile,R as read,F as open,x as mkdtemp,E as mkdir,p as lutimes,k as lstat,W as link,T as lchown,$ as lchmod,_ as futimes,Z as ftruncate,Y as fsync,X as fstat,V as fchown,U as fchmod,O as exists,r as default,N as copyFile,M as close,P as chown,Q as chmod,L as appendFile,K as access};
=======
function B(i,W={}){const S=[];if(i instanceof URL)throw new TypeError("Watch URLs are not supported yet");else if(Buffer.isBuffer(i))i=i.toString();else if(typeof i!=="string")throw new TypeError("Expected path to be a string or Buffer");let k=null;if(typeof W==="string")W={encoding:W};return A.watch(i,W||{},(q,E)=>{if(S.push({eventType:q,filename:E}),k){const z=k;k=null,z()}}),{async*[Symbol.asyncIterator](){let q=!1;while(!q){while(S.length){let E=S.shift();if(E.eventType==="close"){q=!0;break}if(E.eventType==="error")throw q=!0,E.filename;yield E}await new Promise((E)=>k=E)}}}}var A=Bun.fs(),x="::bunternal::",F={[x]:(i)=>{var W={[x]:function(S,k,q){var E;try{E=i.apply(A,q),q=void 0}catch(z){q=void 0,k(z);return}S(E)}}[x];return async function(...S){return await new Promise((k,q)=>{process.nextTick(W,k,q,S)})}}}[x],T=F(A.accessSync),C=F(A.appendFileSync),R=F(A.closeSync),D=F(A.copyFileSync),g=F(A.existsSync),G=F(A.chownSync),h=F(A.chmodSync),H=F(A.fchmodSync),j=F(A.fchownSync),I=F(A.fstatSync),w=F(A.fsyncSync),J=F(A.ftruncateSync),b=F(A.futimesSync),K=F(A.lchmodSync),u=F(A.lchownSync),L=F(A.linkSync),d=F(A.lstatSync),M=F(A.mkdirSync),c=F(A.mkdtempSync),N=F(A.openSync),v=F(A.readSync),O=F(A.writeSync),a=F(A.readdirSync),P=F(A.readFileSync),y=F(A.writeFileSync),Q=F(A.readlinkSync),l=F(A.realpathSync),U=F(A.renameSync),p=F(A.statSync),V=F(A.symlinkSync),m=F(A.truncateSync),X=F(A.unlinkSync),n=F(A.utimesSync),Y=F(A.lutimesSync),t=F(A.rmSync),Z=F(A.rmdirSync),o=(i,W,S)=>{return new Promise((k,q)=>{try{var E=A.writevSync(i,W,S)}catch(z){q(z);return}k({bytesWritten:E,buffers:W})})},_=(i,W,S)=>{return new Promise((k,q)=>{try{var E=A.readvSync(i,W,S)}catch(z){q(z);return}k({bytesRead:E,buffers:W})})},r={access:T,appendFile:C,close:R,copyFile:D,exists:g,chown:G,chmod:h,fchmod:H,fchown:j,fstat:I,fsync:w,ftruncate:J,futimes:b,lchmod:K,lchown:u,link:L,lstat:d,mkdir:M,mkdtemp:c,open:N,read:v,write:O,readdir:a,readFile:P,writeFile:y,readlink:Q,realpath:l,rename:U,stat:p,symlink:V,truncate:m,unlink:X,utimes:n,lutimes:Y,rm:t,rmdir:Z,watch:B,writev:o,readv:_,constants,[Symbol.for("CommonJS")]:0};export{o as writev,y as writeFile,O as write,B as watch,n as utimes,X as unlink,m as truncate,V as symlink,p as stat,Z as rmdir,t as rm,U as rename,l as realpath,_ as readv,Q as readlink,a as readdir,P as readFile,v as read,N as open,c as mkdtemp,M as mkdir,Y as lutimes,d as lstat,L as link,u as lchown,K as lchmod,b as futimes,J as ftruncate,w as fsync,I as fstat,j as fchown,H as fchmod,g as exists,r as default,D as copyFile,R as close,G as chown,h as chmod,C as appendFile,T as access};
>>>>>>> 8fbf24fc (start eventstream)
