<<<<<<< HEAD
<<<<<<< HEAD
function J(B,C={}){const G=[];if(B instanceof URL)throw new TypeError("Watch URLs are not supported yet");else if(Buffer.isBuffer(B))B=B.toString();else if(typeof B!=="string")throw new TypeError("Expected path to be a string or Buffer");let D=null;if(typeof C==="string")C={encoding:C};return S.watch(B,C||{},(z,A)=>{if(G.push({eventType:z,filename:A}),D){const H=D;D=null,H()}}),{async*[Symbol.asyncIterator](){let z=!1;while(!z){while(G.length){let A=G.shift();if(A.eventType==="close"){z=!0;break}if(A.eventType==="error")throw z=!0,A.filename;yield A}await new Promise((A)=>D=A)}}}}var S=Bun.fs(),I="::bunternal::",q={[I]:(B)=>{var C={[I]:function(G,D,z){var A;try{A=B.apply(S,z),z=void 0}catch(H){z=void 0,D(H);return}G(A)}}[I];return async function(...G){return await new Promise((D,z)=>{process.nextTick(C,D,z,G)})}}}[I],K=q(S.accessSync),L=q(S.appendFileSync),M=q(S.closeSync),N=q(S.copyFileSync),O=q(S.existsSync),P=q(S.chownSync),Q=q(S.chmodSync),U=q(S.fchmodSync),V=q(S.fchownSync),X=q(S.fstatSync),Y=q(S.fsyncSync),Z=q(S.ftruncateSync),_=q(S.futimesSync),$=q(S.lchmodSync),T=q(S.lchownSync),W=q(S.linkSync),k=q(S.lstatSync),E=q(S.mkdirSync),x=q(S.mkdtempSync),F=q(S.openSync),R=q(S.readSync),g=q(S.writeSync),h=q(S.readdirSync),j=q(S.readFileSync),w=q(S.writeFileSync),b=q(S.readlinkSync),u=q(S.realpathSync),d=q(S.renameSync),c=q(S.statSync),v=q(S.symlinkSync),a=q(S.truncateSync),y=q(S.unlinkSync),l=q(S.utimesSync),p=q(S.lutimesSync),m=q(S.rmSync),n=q(S.rmdirSync),t=(B,C,G)=>{return new Promise((D,z)=>{try{var A=S.writevSync(B,C,G)}catch(H){z(H);return}D({bytesWritten:A,buffers:C})})},o=(B,C,G)=>{return new Promise((D,z)=>{try{var A=S.readvSync(B,C,G)}catch(H){z(H);return}D({bytesRead:A,buffers:C})})},r={access:K,appendFile:L,close:M,copyFile:N,exists:O,chown:P,chmod:Q,fchmod:U,fchown:V,fstat:X,fsync:Y,ftruncate:Z,futimes:_,lchmod:$,lchown:T,link:W,lstat:k,mkdir:E,mkdtemp:x,open:F,read:R,write:g,readdir:h,readFile:j,writeFile:w,readlink:b,realpath:u,rename:d,stat:c,symlink:v,truncate:a,unlink:y,utimes:l,lutimes:p,rm:m,rmdir:n,watch:J,writev:t,readv:o,constants,[Symbol.for("CommonJS")]:0};export{t as writev,w as writeFile,g as write,J as watch,l as utimes,y as unlink,a as truncate,v as symlink,c as stat,n as rmdir,m as rm,d as rename,u as realpath,o as readv,b as readlink,h as readdir,j as readFile,R as read,F as open,x as mkdtemp,E as mkdir,p as lutimes,k as lstat,W as link,T as lchown,$ as lchmod,_ as futimes,Z as ftruncate,Y as fsync,X as fstat,V as fchown,U as fchmod,O as exists,r as default,N as copyFile,M as close,P as chown,Q as chmod,L as appendFile,K as access};
=======
function B(i,W={}){const S=[];if(i instanceof URL)throw new TypeError("Watch URLs are not supported yet");else if(Buffer.isBuffer(i))i=i.toString();else if(typeof i!=="string")throw new TypeError("Expected path to be a string or Buffer");let k=null;if(typeof W==="string")W={encoding:W};return A.watch(i,W||{},(q,E)=>{if(S.push({eventType:q,filename:E}),k){const z=k;k=null,z()}}),{async*[Symbol.asyncIterator](){let q=!1;while(!q){while(S.length){let E=S.shift();if(E.eventType==="close"){q=!0;break}if(E.eventType==="error")throw q=!0,E.filename;yield E}await new Promise((E)=>k=E)}}}}var A=Bun.fs(),x="::bunternal::",F={[x]:(i)=>{var W={[x]:function(S,k,q){var E;try{E=i.apply(A,q),q=void 0}catch(z){q=void 0,k(z);return}S(E)}}[x];return async function(...S){return await new Promise((k,q)=>{process.nextTick(W,k,q,S)})}}}[x],T=F(A.accessSync),C=F(A.appendFileSync),R=F(A.closeSync),D=F(A.copyFileSync),g=F(A.existsSync),G=F(A.chownSync),h=F(A.chmodSync),H=F(A.fchmodSync),j=F(A.fchownSync),I=F(A.fstatSync),w=F(A.fsyncSync),J=F(A.ftruncateSync),b=F(A.futimesSync),K=F(A.lchmodSync),u=F(A.lchownSync),L=F(A.linkSync),d=F(A.lstatSync),M=F(A.mkdirSync),c=F(A.mkdtempSync),N=F(A.openSync),v=F(A.readSync),O=F(A.writeSync),a=F(A.readdirSync),P=F(A.readFileSync),y=F(A.writeFileSync),Q=F(A.readlinkSync),l=F(A.realpathSync),U=F(A.renameSync),p=F(A.statSync),V=F(A.symlinkSync),m=F(A.truncateSync),X=F(A.unlinkSync),n=F(A.utimesSync),Y=F(A.lutimesSync),t=F(A.rmSync),Z=F(A.rmdirSync),o=(i,W,S)=>{return new Promise((k,q)=>{try{var E=A.writevSync(i,W,S)}catch(z){q(z);return}k({bytesWritten:E,buffers:W})})},_=(i,W,S)=>{return new Promise((k,q)=>{try{var E=A.readvSync(i,W,S)}catch(z){q(z);return}k({bytesRead:E,buffers:W})})},r={access:T,appendFile:C,close:R,copyFile:D,exists:g,chown:G,chmod:h,fchmod:H,fchown:j,fstat:I,fsync:w,ftruncate:J,futimes:b,lchmod:K,lchown:u,link:L,lstat:d,mkdir:M,mkdtemp:c,open:N,read:v,write:O,readdir:a,readFile:P,writeFile:y,readlink:Q,realpath:l,rename:U,stat:p,symlink:V,truncate:m,unlink:X,utimes:n,lutimes:Y,rm:t,rmdir:Z,watch:B,writev:o,readv:_,constants,[Symbol.for("CommonJS")]:0};export{o as writev,y as writeFile,O as write,B as watch,n as utimes,X as unlink,m as truncate,V as symlink,p as stat,Z as rmdir,t as rm,U as rename,l as realpath,_ as readv,Q as readlink,a as readdir,P as readFile,v as read,N as open,c as mkdtemp,M as mkdir,Y as lutimes,d as lstat,L as link,u as lchown,K as lchmod,b as futimes,J as ftruncate,w as fsync,I as fstat,j as fchown,H as fchmod,g as exists,r as default,D as copyFile,R as close,G as chown,h as chmod,C as appendFile,T as access};
>>>>>>> 8fbf24fc (start eventstream)
=======
function P(B,C={}){const D=[];if(B instanceof URL)throw new TypeError("Watch URLs are not supported yet");else if(Buffer.isBuffer(B))B=B.toString();else if(typeof B!=="string")throw new TypeError("Expected path to be a string or Buffer");let z=null;if(typeof C==="string")C={encoding:C};return N.watch(B,C||{},(A,S)=>{if(D.push({eventType:A,filename:S}),z){const q=z;z=null,q()}}),{async*[Symbol.asyncIterator](){let A=!1;while(!A){while(D.length){let S=D.shift();if(S.eventType==="close"){A=!0;break}if(S.eventType==="error")throw A=!0,S.filename;yield S}await new Promise((S)=>z=S)}}}}var N=Bun.fs(),M="::bunternal::",O={[M]:(B)=>{var C={[M]:function(D,z,A){var S;try{S=B.apply(N,A),A=void 0}catch(q){A=void 0,z(q);return}D(S)}}[M];return async function(...D){return await new Promise((z,A)=>{process.nextTick(C,z,A,D)})}}}[M],Q=O(N.accessSync),U=O(N.appendFileSync),V=O(N.closeSync),X=O(N.copyFileSync),d=O(N.existsSync),G=O(N.chownSync),Y=O(N.chmodSync),H=O(N.fchmodSync),Z=O(N.fchownSync),_=O(N.fstatSync),$=O(N.fsyncSync),T=O(N.ftruncateSync),W=O(N.futimesSync),k=O(N.lchmodSync),E=O(N.lchownSync),x=O(N.linkSync),F=O(N.lstatSync),R=O(N.mkdirSync),g=O(N.mkdtempSync),h=O(N.openSync),c=O(N.readSync),j=O(N.writeSync),w=O(N.readdirSync),I=O(N.readFileSync),v=O(N.writeFileSync),J=O(N.readlinkSync),b=O(N.realpathSync),u=O(N.renameSync),y=O(N.statSync),l=O(N.symlinkSync),p=O(N.truncateSync),m=O(N.unlinkSync),n=O(N.utimesSync),t=O(N.lutimesSync),o=O(N.rmSync),r=O(N.rmdirSync),a=(B,C,D)=>{return new Promise((z,A)=>{try{var S=N.writevSync(B,C,D)}catch(q){A(q);return}z({bytesWritten:S,buffers:C})})},K=(B,C,D)=>{return new Promise((z,A)=>{try{var S=N.readvSync(B,C,D)}catch(q){A(q);return}z({bytesRead:S,buffers:C})})},i={access:Q,appendFile:U,close:V,copyFile:X,exists:d,chown:G,chmod:Y,fchmod:H,fchown:Z,fstat:_,fsync:$,ftruncate:T,futimes:W,lchmod:k,lchown:E,link:x,lstat:F,mkdir:R,mkdtemp:g,open:h,read:c,write:j,readdir:w,readFile:I,writeFile:v,readlink:J,realpath:b,rename:u,stat:y,symlink:l,truncate:p,unlink:m,utimes:n,lutimes:t,rm:o,rmdir:r,watch:P,writev:a,readv:K,constants,[Symbol.for("CommonJS")]:0};export{a as writev,v as writeFile,j as write,P as watch,n as utimes,m as unlink,p as truncate,l as symlink,y as stat,r as rmdir,o as rm,u as rename,b as realpath,K as readv,J as readlink,w as readdir,I as readFile,c as read,h as open,g as mkdtemp,R as mkdir,t as lutimes,F as lstat,x as link,E as lchown,k as lchmod,W as futimes,T as ftruncate,$ as fsync,_ as fstat,Z as fchown,H as fchmod,d as exists,i as default,X as copyFile,V as close,G as chown,Y as chmod,U as appendFile,Q as access};
>>>>>>> bb697687 (stuff)
