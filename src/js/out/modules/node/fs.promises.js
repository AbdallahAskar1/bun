<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
<<<<<<< HEAD
function J(B,C={}){const G=[];if(B instanceof URL)throw new TypeError("Watch URLs are not supported yet");else if(Buffer.isBuffer(B))B=B.toString();else if(typeof B!=="string")throw new TypeError("Expected path to be a string or Buffer");let D=null;if(typeof C==="string")C={encoding:C};return S.watch(B,C||{},(z,A)=>{if(G.push({eventType:z,filename:A}),D){const H=D;D=null,H()}}),{async*[Symbol.asyncIterator](){let z=!1;while(!z){while(G.length){let A=G.shift();if(A.eventType==="close"){z=!0;break}if(A.eventType==="error")throw z=!0,A.filename;yield A}await new Promise((A)=>D=A)}}}}var S=Bun.fs(),I="::bunternal::",q={[I]:(B)=>{var C={[I]:function(G,D,z){var A;try{A=B.apply(S,z),z=void 0}catch(H){z=void 0,D(H);return}G(A)}}[I];return async function(...G){return await new Promise((D,z)=>{process.nextTick(C,D,z,G)})}}}[I],K=q(S.accessSync),L=q(S.appendFileSync),M=q(S.closeSync),N=q(S.copyFileSync),O=q(S.existsSync),P=q(S.chownSync),Q=q(S.chmodSync),U=q(S.fchmodSync),V=q(S.fchownSync),X=q(S.fstatSync),Y=q(S.fsyncSync),Z=q(S.ftruncateSync),_=q(S.futimesSync),$=q(S.lchmodSync),T=q(S.lchownSync),W=q(S.linkSync),k=q(S.lstatSync),E=q(S.mkdirSync),x=q(S.mkdtempSync),F=q(S.openSync),R=q(S.readSync),g=q(S.writeSync),h=q(S.readdirSync),j=q(S.readFileSync),w=q(S.writeFileSync),b=q(S.readlinkSync),u=q(S.realpathSync),d=q(S.renameSync),c=q(S.statSync),v=q(S.symlinkSync),a=q(S.truncateSync),y=q(S.unlinkSync),l=q(S.utimesSync),p=q(S.lutimesSync),m=q(S.rmSync),n=q(S.rmdirSync),t=(B,C,G)=>{return new Promise((D,z)=>{try{var A=S.writevSync(B,C,G)}catch(H){z(H);return}D({bytesWritten:A,buffers:C})})},o=(B,C,G)=>{return new Promise((D,z)=>{try{var A=S.readvSync(B,C,G)}catch(H){z(H);return}D({bytesRead:A,buffers:C})})},r={access:K,appendFile:L,close:M,copyFile:N,exists:O,chown:P,chmod:Q,fchmod:U,fchown:V,fstat:X,fsync:Y,ftruncate:Z,futimes:_,lchmod:$,lchown:T,link:W,lstat:k,mkdir:E,mkdtemp:x,open:F,read:R,write:g,readdir:h,readFile:j,writeFile:w,readlink:b,realpath:u,rename:d,stat:c,symlink:v,truncate:a,unlink:y,utimes:l,lutimes:p,rm:m,rmdir:n,watch:J,writev:t,readv:o,constants,[Symbol.for("CommonJS")]:0};export{t as writev,w as writeFile,g as write,J as watch,l as utimes,y as unlink,a as truncate,v as symlink,c as stat,n as rmdir,m as rm,d as rename,u as realpath,o as readv,b as readlink,h as readdir,j as readFile,R as read,F as open,x as mkdtemp,E as mkdir,p as lutimes,k as lstat,W as link,T as lchown,$ as lchmod,_ as futimes,Z as ftruncate,Y as fsync,X as fstat,V as fchown,U as fchmod,O as exists,r as default,N as copyFile,M as close,P as chown,Q as chmod,L as appendFile,K as access};
=======
function B(i,W={}){const S=[];if(i instanceof URL)throw new TypeError("Watch URLs are not supported yet");else if(Buffer.isBuffer(i))i=i.toString();else if(typeof i!=="string")throw new TypeError("Expected path to be a string or Buffer");let k=null;if(typeof W==="string")W={encoding:W};return A.watch(i,W||{},(q,E)=>{if(S.push({eventType:q,filename:E}),k){const z=k;k=null,z()}}),{async*[Symbol.asyncIterator](){let q=!1;while(!q){while(S.length){let E=S.shift();if(E.eventType==="close"){q=!0;break}if(E.eventType==="error")throw q=!0,E.filename;yield E}await new Promise((E)=>k=E)}}}}var A=Bun.fs(),x="::bunternal::",F={[x]:(i)=>{var W={[x]:function(S,k,q){var E;try{E=i.apply(A,q),q=void 0}catch(z){q=void 0,k(z);return}S(E)}}[x];return async function(...S){return await new Promise((k,q)=>{process.nextTick(W,k,q,S)})}}}[x],T=F(A.accessSync),C=F(A.appendFileSync),R=F(A.closeSync),D=F(A.copyFileSync),g=F(A.existsSync),G=F(A.chownSync),h=F(A.chmodSync),H=F(A.fchmodSync),j=F(A.fchownSync),I=F(A.fstatSync),w=F(A.fsyncSync),J=F(A.ftruncateSync),b=F(A.futimesSync),K=F(A.lchmodSync),u=F(A.lchownSync),L=F(A.linkSync),d=F(A.lstatSync),M=F(A.mkdirSync),c=F(A.mkdtempSync),N=F(A.openSync),v=F(A.readSync),O=F(A.writeSync),a=F(A.readdirSync),P=F(A.readFileSync),y=F(A.writeFileSync),Q=F(A.readlinkSync),l=F(A.realpathSync),U=F(A.renameSync),p=F(A.statSync),V=F(A.symlinkSync),m=F(A.truncateSync),X=F(A.unlinkSync),n=F(A.utimesSync),Y=F(A.lutimesSync),t=F(A.rmSync),Z=F(A.rmdirSync),o=(i,W,S)=>{return new Promise((k,q)=>{try{var E=A.writevSync(i,W,S)}catch(z){q(z);return}k({bytesWritten:E,buffers:W})})},_=(i,W,S)=>{return new Promise((k,q)=>{try{var E=A.readvSync(i,W,S)}catch(z){q(z);return}k({bytesRead:E,buffers:W})})},r={access:T,appendFile:C,close:R,copyFile:D,exists:g,chown:G,chmod:h,fchmod:H,fchown:j,fstat:I,fsync:w,ftruncate:J,futimes:b,lchmod:K,lchown:u,link:L,lstat:d,mkdir:M,mkdtemp:c,open:N,read:v,write:O,readdir:a,readFile:P,writeFile:y,readlink:Q,realpath:l,rename:U,stat:p,symlink:V,truncate:m,unlink:X,utimes:n,lutimes:Y,rm:t,rmdir:Z,watch:B,writev:o,readv:_,constants,[Symbol.for("CommonJS")]:0};export{o as writev,y as writeFile,O as write,B as watch,n as utimes,X as unlink,m as truncate,V as symlink,p as stat,Z as rmdir,t as rm,U as rename,l as realpath,_ as readv,Q as readlink,a as readdir,P as readFile,v as read,N as open,c as mkdtemp,M as mkdir,Y as lutimes,d as lstat,L as link,u as lchown,K as lchmod,b as futimes,J as ftruncate,w as fsync,I as fstat,j as fchown,H as fchmod,g as exists,r as default,D as copyFile,R as close,G as chown,h as chmod,C as appendFile,T as access};
>>>>>>> 8fbf24fc (start eventstream)
=======
function P(B,C={}){const D=[];if(B instanceof URL)throw new TypeError("Watch URLs are not supported yet");else if(Buffer.isBuffer(B))B=B.toString();else if(typeof B!=="string")throw new TypeError("Expected path to be a string or Buffer");let z=null;if(typeof C==="string")C={encoding:C};return N.watch(B,C||{},(A,S)=>{if(D.push({eventType:A,filename:S}),z){const q=z;z=null,q()}}),{async*[Symbol.asyncIterator](){let A=!1;while(!A){while(D.length){let S=D.shift();if(S.eventType==="close"){A=!0;break}if(S.eventType==="error")throw A=!0,S.filename;yield S}await new Promise((S)=>z=S)}}}}var N=Bun.fs(),M="::bunternal::",O={[M]:(B)=>{var C={[M]:function(D,z,A){var S;try{S=B.apply(N,A),A=void 0}catch(q){A=void 0,z(q);return}D(S)}}[M];return async function(...D){return await new Promise((z,A)=>{process.nextTick(C,z,A,D)})}}}[M],Q=O(N.accessSync),U=O(N.appendFileSync),V=O(N.closeSync),X=O(N.copyFileSync),d=O(N.existsSync),G=O(N.chownSync),Y=O(N.chmodSync),H=O(N.fchmodSync),Z=O(N.fchownSync),_=O(N.fstatSync),$=O(N.fsyncSync),T=O(N.ftruncateSync),W=O(N.futimesSync),k=O(N.lchmodSync),E=O(N.lchownSync),x=O(N.linkSync),F=O(N.lstatSync),R=O(N.mkdirSync),g=O(N.mkdtempSync),h=O(N.openSync),c=O(N.readSync),j=O(N.writeSync),w=O(N.readdirSync),I=O(N.readFileSync),v=O(N.writeFileSync),J=O(N.readlinkSync),b=O(N.realpathSync),u=O(N.renameSync),y=O(N.statSync),l=O(N.symlinkSync),p=O(N.truncateSync),m=O(N.unlinkSync),n=O(N.utimesSync),t=O(N.lutimesSync),o=O(N.rmSync),r=O(N.rmdirSync),a=(B,C,D)=>{return new Promise((z,A)=>{try{var S=N.writevSync(B,C,D)}catch(q){A(q);return}z({bytesWritten:S,buffers:C})})},K=(B,C,D)=>{return new Promise((z,A)=>{try{var S=N.readvSync(B,C,D)}catch(q){A(q);return}z({bytesRead:S,buffers:C})})},i={access:Q,appendFile:U,close:V,copyFile:X,exists:d,chown:G,chmod:Y,fchmod:H,fchown:Z,fstat:_,fsync:$,ftruncate:T,futimes:W,lchmod:k,lchown:E,link:x,lstat:F,mkdir:R,mkdtemp:g,open:h,read:c,write:j,readdir:w,readFile:I,writeFile:v,readlink:J,realpath:b,rename:u,stat:y,symlink:l,truncate:p,unlink:m,utimes:n,lutimes:t,rm:o,rmdir:r,watch:P,writev:a,readv:K,constants,[Symbol.for("CommonJS")]:0};export{a as writev,v as writeFile,j as write,P as watch,n as utimes,m as unlink,p as truncate,l as symlink,y as stat,r as rmdir,o as rm,u as rename,b as realpath,K as readv,J as readlink,w as readdir,I as readFile,c as read,h as open,g as mkdtemp,R as mkdir,t as lutimes,F as lstat,x as link,E as lchown,k as lchmod,W as futimes,T as ftruncate,$ as fsync,_ as fstat,Z as fchown,H as fchmod,d as exists,i as default,X as copyFile,V as close,G as chown,Y as chmod,U as appendFile,Q as access};
>>>>>>> bb697687 (stuff)
=======
function H(h,B={}){const j=[];if(h instanceof URL)throw new TypeError("Watch URLs are not supported yet");else if(Buffer.isBuffer(h))h=h.toString();else if(typeof h!=="string")throw new TypeError("Expected path to be a string or Buffer");let z=null;if(typeof B==="string")B={encoding:B};return D.watch(h,B||{},(A,S)=>{if(j.push({eventType:A,filename:S}),z){const q=z;z=null,q()}}),{async*[Symbol.asyncIterator](){let A=!1;while(!A){while(j.length){let S=j.shift();if(S.eventType==="close"){A=!0;break}if(S.eventType==="error")throw A=!0,S.filename;yield S}await new Promise((S)=>z=S)}}}}var D=Bun.fs(),C="::bunternal::",G={[C]:(h)=>{var B={[C]:function(j,z,A){var S;try{S=h.apply(D,A),A=void 0}catch(q){A=void 0,z(q);return}j(S)}}[C];return async function(...j){return await new Promise((z,A)=>{process.nextTick(B,z,A,j)})}}}[C],I=G(D.accessSync),J=G(D.appendFileSync),K=G(D.closeSync),L=G(D.copyFileSync),w=G(D.existsSync),F=G(D.chownSync),M=G(D.chmodSync),b=G(D.fchmodSync),N=G(D.fchownSync),O=G(D.fstatSync),P=G(D.fsyncSync),Q=G(D.ftruncateSync),U=G(D.futimesSync),V=G(D.lchmodSync),X=G(D.lchownSync),Y=G(D.linkSync),Z=G(D.lstatSync),_=G(D.mkdirSync),$=G(D.mkdtempSync),T=G(D.openSync),u=G(D.readSync),W=G(D.writeSync),k=G(D.readdirSync),d=G(D.readFileSync),c=G(D.writeFileSync),R=G(D.readlinkSync),E=G(D.realpathSync),x=G(D.renameSync),v=G(D.statSync),a=G(D.symlinkSync),y=G(D.truncateSync),l=G(D.unlinkSync),p=G(D.utimesSync),m=G(D.lutimesSync),n=G(D.rmSync),t=G(D.rmdirSync),o=(h,B,j)=>{return new Promise((z,A)=>{try{var S=D.writevSync(h,B,j)}catch(q){A(q);return}z({bytesWritten:S,buffers:B})})},g=(h,B,j)=>{return new Promise((z,A)=>{try{var S=D.readvSync(h,B,j)}catch(q){A(q);return}z({bytesRead:S,buffers:B})})},r={access:I,appendFile:J,close:K,copyFile:L,exists:w,chown:F,chmod:M,fchmod:b,fchown:N,fstat:O,fsync:P,ftruncate:Q,futimes:U,lchmod:V,lchown:X,link:Y,lstat:Z,mkdir:_,mkdtemp:$,open:T,read:u,write:W,readdir:k,readFile:d,writeFile:c,readlink:R,realpath:E,rename:x,stat:v,symlink:a,truncate:y,unlink:l,utimes:p,lutimes:m,rm:n,rmdir:t,watch:H,writev:o,readv:g,constants,[Symbol.for("CommonJS")]:0};export{o as writev,c as writeFile,W as write,H as watch,p as utimes,l as unlink,y as truncate,a as symlink,v as stat,t as rmdir,n as rm,x as rename,E as realpath,g as readv,R as readlink,k as readdir,d as readFile,u as read,T as open,$ as mkdtemp,_ as mkdir,m as lutimes,Z as lstat,Y as link,X as lchown,V as lchmod,U as futimes,Q as ftruncate,P as fsync,O as fstat,N as fchown,b as fchmod,w as exists,r as default,L as copyFile,K as close,F as chown,M as chmod,J as appendFile,I as access};
>>>>>>> f0a3559e (add a workaround for eventstream headers)
=======
function C(S,k={}){const q=[];if(S instanceof URL)throw new TypeError("Watch URLs are not supported yet");else if(Buffer.isBuffer(S))S=S.toString();else if(typeof S!=="string")throw new TypeError("Expected path to be a string or Buffer");let E=null;if(typeof k==="string")k={encoding:k};return B.watch(S,k||{},(z,x)=>{if(q.push({eventType:z,filename:x}),E){const A=E;E=null,A()}}),{async*[Symbol.asyncIterator](){let z=!1;while(!z){while(q.length){let x=q.shift();if(x.eventType==="close"){z=!0;break}if(x.eventType==="error")throw z=!0,x.filename;yield x}await new Promise((x)=>E=x)}}}}var B=Bun.fs(),F="::bunternal::",R={[F]:(S)=>{var k={[F]:function(q,E,z){var x;try{x=S.apply(B,z),z=void 0}catch(A){z=void 0,E(A);return}q(x)}}[F];return async function(...q){return await new Promise((E,z)=>{process.nextTick(k,E,z,q)})}}}[F],W=R(B.accessSync),D=R(B.appendFileSync),g=R(B.closeSync),G=R(B.copyFileSync),h=R(B.existsSync),H=R(B.chownSync),j=R(B.chmodSync),I=R(B.fchmodSync),w=R(B.fchownSync),J=R(B.fstatSync),b=R(B.fsyncSync),K=R(B.ftruncateSync),u=R(B.futimesSync),L=R(B.lchmodSync),d=R(B.lchownSync),M=R(B.linkSync),c=R(B.lstatSync),N=R(B.mkdirSync),v=R(B.mkdtempSync),O=R(B.openSync),a=R(B.readSync),P=R(B.writeSync),y=R(B.readdirSync),Q=R(B.readFileSync),l=R(B.writeFileSync),U=R(B.readlinkSync),p=R(B.realpathSync),V=R(B.renameSync),m=R(B.statSync),X=R(B.symlinkSync),n=R(B.truncateSync),Y=R(B.unlinkSync),t=R(B.utimesSync),Z=R(B.lutimesSync),o=R(B.rmSync),_=R(B.rmdirSync),r=(S,k,q)=>{return new Promise((E,z)=>{try{var x=B.writevSync(S,k,q)}catch(A){z(A);return}E({bytesWritten:x,buffers:k})})},$=(S,k,q)=>{return new Promise((E,z)=>{try{var x=B.readvSync(S,k,q)}catch(A){z(A);return}E({bytesRead:x,buffers:k})})},i={access:W,appendFile:D,close:g,copyFile:G,exists:h,chown:H,chmod:j,fchmod:I,fchown:w,fstat:J,fsync:b,ftruncate:K,futimes:u,lchmod:L,lchown:d,link:M,lstat:c,mkdir:N,mkdtemp:v,open:O,read:a,write:P,readdir:y,readFile:Q,writeFile:l,readlink:U,realpath:p,rename:V,stat:m,symlink:X,truncate:n,unlink:Y,utimes:t,lutimes:Z,rm:o,rmdir:_,watch:C,writev:r,readv:$,constants,[Symbol.for("CommonJS")]:0};export{r as writev,l as writeFile,P as write,C as watch,t as utimes,Y as unlink,n as truncate,X as symlink,m as stat,_ as rmdir,o as rm,V as rename,p as realpath,$ as readv,U as readlink,y as readdir,Q as readFile,a as read,O as open,v as mkdtemp,N as mkdir,Z as lutimes,c as lstat,M as link,d as lchown,L as lchmod,u as futimes,K as ftruncate,b as fsync,J as fstat,w as fchown,I as fchmod,h as exists,i as default,G as copyFile,g as close,H as chown,j as chmod,D as appendFile,W as access};
>>>>>>> e876ca3a (flush and cancel in node:http)
